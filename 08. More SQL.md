## More Complex SQL Retrieval Queries
### Comparisons Involving NULL and Three-Valued Logic
   - NULL
      - 알 수 없는 값, 사용할 수 없거나 보류된 값, 적용할 수 없음
   - Three-valued logic // 3가 논리 
   
   | AND | TRUE | FALSE | UNKNOWN |   
   |:---:|:---:|:---:|:---:|   
   | TRUE | TRUE | FALSE | UNKNOWN |   
   | FALSE | FALSE | FALSE | FALSE |   
   | UNKNOWN | UNKNOWN | FALSE | UNKNOWN |   
   
   - IS [NOT] NULL // Null 값의 유무를 물어볼 때
   - QUERY 18: 상사가 없는 모든 직원의 이름을 검색하라
   - Q18:
      ```
      SELECT Fname, Lname
      FROM   EMPLOYEE
      WHERE  Super_ssn IS NULL;
      ```
      
   ![08-01](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-01.jpg?raw=true)   
   
   ![08-02](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-02.jpg?raw=true)   
---

### Nested Queries, Tuples, and Set/Multiset Comparisons
   - Nested queries // 중첩 질의
      - 다른 query(outer query라고 함)의 WHERE-clause 내에서 SELECT...FROM...WHERE... 블록이 포함 
         - nested query = inner query = sub query   
         
      ![08-03](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-03.jpg?raw=true)  
      
      ![08-04](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-04.jpg?raw=true)   
      
      ![08-05](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-05.jpg?raw=true)   
      
      ![08-06](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-06.jpg?raw=true)    
      
   - QUERY 4
      - 성이 'Smith'인 직원이 포함된 프로젝트의 모든 프로젝트 번호를 근로자 또는 프로젝트를 관리하는 부서의 관리자로 리스트 작성
      작성
         ```
         (  SELECT  DISTINCT Pnumber
            FROM    PROJECT, DEPARTMENT, EMPLOYEE
            WHERE   Dnum=Dnumber AND Mgr_ssn=Ssn AND Lname='Smith'  )
         UNION
         (  SELECT  DISTINCT Pno
            FROM    WORKS_ON, EMPLOYEE
            WHERE   Essn=Ssn AND Lname='Smith'  );
         ```
         
         ```
         SELECT DISTINCT Pnumber
         FROM   PROJECT
         WHERE  Pnumber IN
         (  SELECT  DISTINCT Pnumber
            FROM    PROJECT, DEPARTMENT, EMPLOYEE
            WHERE   Dnum=Dnumber AND Mgr_ssn=Ssn AND Lname='Smith'  )
            OR  Pnumber IN
         (  SELECT  DISTINCT Pno
            FROM    WORKS_ON, EMPLOYEE
            WHERE   Essn=Ssn AND Lname='Smith'  );
         ```
         
      - Q4A:
         ![08-07](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-07.jpg?raw=true)   
         
         ![08-08](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-08.jpg?raw=true)   
         
      - 또한 IN 연산자는 괄호 안에 있는 값의 튜플을 union-compatible tuples 세트 또는 멀티셋과 비교할 수 있음
         ```
         SELECT DISTINCT Essn
         FROM   WORKS_ON
         WHERE  (Pno, Hours) IN ( SELECT  Pno, Hours // 구조가 같아야 함
                                  FROM    WORKS_ON
                                  WHERE   Essn='123456789'  );
         ```
         ![08-12](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-12.jpg?raw=true)   
         
      - >, >=, <, <=, <>, = ANY(또는 SOME) 또는 ALL
         ```
         SELECT Lname, Fname
         FROM   EMPLOYEE
         WHRE   Salary > ALL (  SELECT  Salary  FROM  EMPLOYEE  WHERE Dno=5 );
         ```
         
      - 속성 이름 간의 모호성
         - 부적격 속성에 대한 참조는 가장 내포된 query에서 선언된 관계를 가리킴
      - QUERY 16
         - 직원과 이름이 같고 성별이 같은 부양가족이 있는 각 직원의 이름을 검색하라
         ![08-13](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-13.jpg?raw=true)   
         
         ![08-14](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-14.jpg?raw=true)   
         
         ```
         SELECT E.Fname, E.Lname
         FROM   EMPLOYEE AS E
         WHERE  E.Ssn IN (  SELECT  Essn
                            FROM    DEPENDENT
                            WHERE   E.Fname=Dependent_name AND E.Sex=Sex  );
         ```
         
         ![08-15](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-15.jpg?raw=true)   
         
         ![08-16](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-16.jpg?raw=true)   
         
         ```
         SELECT E.Fname, E.Lname
         FROM   EMPLOYEE AS E
         WHERE  E.Ssn IN (  SELECT  Essn
                            FROM    DEPENDENT
                            WHERE   'John'=Dependent_name AND 'M'=Sex );
         ```
---

### Correlated Nested Queries
   - Correlated queries
      - nested query의 WHERE-clause에 있는 조건이 outer query에 선언된 관계의 일부 속성을 참조하는 경우
      - nested query는 outer query의 각 튜플에 대해 한 번 수행됨(Q16)
      - 일반적으로 nested SELECT...FROM...WHERE... 블록으로 작성된 query 와 = 또는 IN 비교 연산자를 사용하는 query는 항상 단일 블록 query로 표현될 수 있음
      ![08-17](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-17.jpg?raw=true)   
---

### EXITS and UNIQUE Functions
   - correlated nested query의 결과가 비어(튜플이 없음) 있는 지 확인
      - EXITS(Q)는 query Q의 결과에 적어도 하나의 튜플이 있을 경우 TRUE를 반환하고, 그렇지 않을 경우 FALSE를 반환함
   - Q16B:
      ```
      SELECT   E.Fname, E.Lname
      FROM     EMPLOYEE AS E
      WHERE    EXISTS (
                        SELECT   *
                        FROM     DEPENDENT
                        WHERE    E.Ssn=Essn AND E.Sex=Sex AND E.Fname=Dependent_name   );
      ```
      
      ![08-18](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-18.jpg?raw=true)   
      
   - QUERY 6
      - 부양 가족이 없는 직원 이름 검색
   - Q6:
      ```
      SELECT   Fname, Lname
      FROM     EMPLOYEE
      WHERE    NOT EXITST ( SELECT  *
                            FROM    DEPENDENT
                            WHERE   Ssn=Essn );
      ```
      ![08-19](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-19.jpg?raw=true)   
      
   - UNIQUE(Q) functions
      - query Q의 결과에 중복 튜플이 없는 경우 TRUE;
      - 그렇지 않으면 FALSE를 반환
      ```
      SELECT   Fname, Lname
      FROM     EMPLOYEE
      WHERE    UNIQUE ( SELECT   Sex // DISTINCT를 사용하면 항상 TRUE
                        FROM     DEPENDENT
                        WHERE    Essn=EMPLOYEE.Ssn );
      ```
      
      ![08-20]()
      
   - QUERY 7
      - 하나 이상의 부양가족이 있는 관리자 이름을 나열하라
   - Q7:   
   
      ![08-21]()   
      
      ![08-22]()   
      
      ```
      DELETE FROM EMPLOYEE
      WHERE  Dno=5;
      
      DELETE FROM EMPLOYEE
      WHERE  Dno IN (   SELECT   Dnumber // 조건이 여러개 겹치면 중첩질의어를 쓸 수 밖에 없음
                        FROM     DEPARTMENT
                        WHERE    Dname='Research'  );
      
      UPDATE EMPLOYEE
      SET    Salary = Salary * 1.1
      WHERE  Dno IN (   SELECT   Dnumber
                        FROM     DEPARTMENT
                        WHERE    Dname='Research'  );
      ```
---

### Explicit Sets and Renaming Attributes
   - QUERY 17
      - 1번, 2번 또는 3번 프로젝트에서 일하는 모든 직원의 사회 보장 번호를 검색하라
   - Q17:
      ```
      SELECT DISTINCT Essn
      FROM   WORKS_ON
      WHERE  Pno IN (1,2,3);
      ```
---

### Renaming Attributes
   - Q8A:
      ```
      SELECT   E.Lname AS Emp_Name, S.Lname AS Spvsr_Name
      FROM     EMPLOYEE AS E, EMPLOYEE AS S
      WHERE    E.Super_ssn=S.Ssn;
      ```
---

### Joined Table
   - query의 FROM-clause에서 조인 연산으로 인한 테이블 지정
   - Q1A:
      ```
      SELECT   Fname, Lname, Address
      FROM     (EMPLOYEE JOIN DEPARTMENT ON Dno=Dnumber)
      WHERE    Dname='Research';
      ```
      ![08-23]()   
      
      ![08-24]()  
      
      ![08-25]()   
      
   - Types of join: NATURAL JOIN, OUTER JOIN
   - R과 S의 두 관계에서 NATURAL JOIN을 할 때,
      - 조인 조건이 지정되지 않음
      - R과 S에서 이름이 같은 각 속성 쌍에 대한 암시적 EQUIJOIN 조건이 생성 됨 // EQUIJOIN의 예는 바로 위의 사진
      - 이러한 각 속성 쌍은 결과 관계에 한 번만 포함됨 
      
   - Q1B:
      ```
      SELECT   Fname, Lname, Address
      FROM     (  EMPLOYEE NATURAL JOIN
                  (  DEPARTMENT AS DEPT(Dname, Dno, Mssn, Msdate)  )  )
      WHERE    Dname='Research'; 
      ```
      
      ![08-26]()   
      
      ![08-27]()   
      
      ![08-28]()   
      
   - Inner Join
      - 튜플은 다른 관계에서 일치하는 튜플이 존재하는 경우에만 결과에 포함됨
      - 예, query Q8A에서
         - 감독관이 있는 직원만 결과에 포함
         - Superr_ssn 값이 NULL인 EMPLOYEE 튜플이 제외 됨
   - 사용자가 모든 직원을 포함하도록 요구하는 경우 OUTER JOIN을 명시적으로 사용해야 함
   - 조인된 테이블의 기본 조인 유형은 inner join   
   
      ![08-29]()   
      
      ![08-30]()   
      
   - Q8B:
      ```
      SELECT   E.Lname AS Employee_name, S.Lname AS Supervisor_name
      FROM     (  EMPLOYEE AS E LEFT OUTER JOIN
                  EMPLOYEE AS S ON E.Super_ssn=S.Ssn  );
      ```
      - Othions
         - INNER JOIN(JOIN과 같음)
         - LEFT [OUTER] JOIN // OUTER 생략 가능
         - RIGHT [OUTER] JOIN
         - FULL [OUTER] JOINT
         - NATURAL JOIN   
         
      ![08-31]()   
      
   - Q2A: multiway join
      ```
      SELECT   Pnumber, Dnum, Lname, Address, Bdate
      FROM     (  (  PROJECT JOIN DEPARTMENT ON Dnum=Dnumber   ) JOIN EMPLOYEE ON Mgr_ssn=Ssn   )
      WHERE    Plocation='Stafford';
      ```
---

#### cf)

   - 모든 SQL 구현이 조인된 테이블의 새로운 구문을 구현한 것은 아님. 일부 시스템에서는 조인 조건을 지정할 때 각각 왼쪽, 오른쪽, 전체 외부 조인에 대해 비교 연산자 +=, =+, =+=를 사용하여 외부 조인을 지정하는 데 다른 구문을 사용하였음. 예를 들어, 이 구문에서 Oracle에서 사용할 수 있음. 이 구문을 사용하여 Q8B 왼쪽 외부 조인을 지정하려면 Q8C query를 다음과 같이 작성하면 됨
   - Q8C:
      ```
      SELECT   E.Lname, S.Lname
      FROM     EMPLOYEE E, EMPLOYEE S
      WHERE    E.Super_ssn += S.Ssn;
      ```
--- 
 
#### JOIN
   1. Inner Join
      - EQUIJOIN
         - Natural Join
      - 세트-Join: 세타 = {부등호, 등호 등등}
   2. Outer Join // 외부 조인
--- 


      
      
   
      
         
         
