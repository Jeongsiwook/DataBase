## More Complex SQL Retrieval Queries
### Comparisons Involving NULL and Three-Valued Logic
   - NULL
      - 알 수 없는 값, 사용할 수 없거나 보류된 값, 적용할 수 없음
   - Three-valued logic // 3가 논리 
   
   | AND | TRUE | FALSE | UNKNOWN |   
   |:---:|:---:|:---:|:---:|   
   | TRUE | TRUE | FALSE | UNKNOWN |   
   | FALSE | FALSE | FALSE | FALSE |   
   | UNKNOWN | UNKNOWN | FALSE | UNKNOWN |   
   
   - IS [NOT] NULL // Null 값의 유무를 물어볼 때
   - QUERY 18: 상사가 없는 모든 직원의 이름을 검색하라
   - Q18:
      ```
      SELECT Fname, Lname
      FROM   EMPLOYEE
      WHERE  Super_ssn IS NULL;
      ```
      
   ![08-01](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-01.jpg?raw=true)   
   
   ![08-02](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-02.jpg?raw=true)   
---

### Nested Queries, Tuples, and Set/Multiset Comparisons
   - Nested queries // 중첩 질의
      - 다른 query(outer query라고 함)의 WHERE-clause 내에서 SELECT...FROM...WHERE... 블록이 포함 
         - nested query = inner query = sub query   
         
      ![08-03](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-03.jpg?raw=true)  
      
      ![08-04](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-04.jpg?raw=true)   
      
      ![08-05](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-05.jpg?raw=true)   
      
      ![08-06](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-06.jpg?raw=true)    
      
   - QUERY 4
      - 성이 'Smith'인 직원이 포함된 프로젝트의 모든 프로젝트 번호를 근로자 또는 프로젝트를 관리하는 부서의 관리자로 리스트 작성
      작성
         ```
         (  SELECT  DISTINCT Pnumber
            FROM    PROJECT, DEPARTMENT, EMPLOYEE
            WHERE   Dnum=Dnumber AND Mgr_ssn=Ssn AND Lname='Smith'  )
         UNION
         (  SELECT  DISTINCT Pno
            FROM    WORKS_ON, EMPLOYEE
            WHERE   Essn=Ssn AND Lname='Smith'  );
         ```
         
         ```
         SELECT DISTINCT Pnumber
         FROM   PROJECT
         WHERE  Pnumber IN
         (  SELECT  DISTINCT Pnumber
            FROM    PROJECT, DEPARTMENT, EMPLOYEE
            WHERE   Dnum=Dnumber AND Mgr_ssn=Ssn AND Lname='Smith'  )
            OR  Pnumber IN
         (  SELECT  DISTINCT Pno
            FROM    WORKS_ON, EMPLOYEE
            WHERE   Essn=Ssn AND Lname='Smith'  );
         ```
         
      - Q4A:
         ![08-07](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-07.jpg?raw=true)   
         
         ![08-08](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-08.jpg?raw=true)   
         
      - 또한 IN 연산자는 괄호 안에 있는 값의 튜플을 union-compatible tuples 세트 또는 멀티셋과 비교할 수 있음
         ```
         SELECT DISTINCT Essn
         FROM   WORKS_ON
         WHERE  (Pno, Hours) IN ( SELECT  Pno, Hours // 구조가 같아야 함
                                  FROM    WORKS_ON
                                  WHERE   Essn='123456789'  );
         ```
         ![08-12](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-12.jpg?raw=true)   
         
      - >, >=, <, <=, <>, = ANY(또는 SOME) 또는 ALL
         ```
         SELECT Lname, Fname
         FROM   EMPLOYEE
         WHRE   Salary > ALL (  SELECT  Salary  FROM  EMPLOYEE  WHERE Dno=5 );
         ```
         
      - 속성 이름 간의 모호성
         - 부적격 속성에 대한 참조는 가장 내포된 query에서 선언된 관계를 가리킴
      - QUERY 16
         - 직원과 이름이 같고 성별이 같은 부양가족이 있는 각 직원의 이름을 검색하라
         ![08-13](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-13.jpg?raw=true)   
         
         ![08-14](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-14.jpg?raw=true)   
         
         ```
         SELECT E.Fname, E.Lname
         FROM   EMPLOYEE AS E
         WHERE  E.Ssn IN (  SELECT  Essn
                            FROM    DEPENDENT
                            WHERE   E.Fname=Dependent_name AND E.Sex=Sex  );
         ```
         
         ![08-15](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-15.jpg?raw=true)   
         
         ![08-16](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-16.jpg?raw=true)   
         
         ```
         SELECT E.Fname, E.Lname
         FROM   EMPLOYEE AS E
         WHERE  E.Ssn IN (  SELECT  Essn
                            FROM    DEPENDENT
                            WHERE   'John'=Dependent_name AND 'M'=Sex );
         ```
---

### Correlated Nested Queries
   - Correlated queries
      - nested query의 WHERE-clause에 있는 조건이 outer query에 선언된 관계의 일부 속성을 참조하는 경우
      - nested query는 outer query의 각 튜플에 대해 한 번 수행됨(Q16)
      - 일반적으로 nested SELECT...FROM...WHERE... 블록으로 작성된 query 와 = 또는 IN 비교 연산자를 사용하는 query는 항상 단일 블록 query로 표현될 수 있음
      ![08-17](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-17.jpg?raw=true)   
---

### EXITS and UNIQUE Functions
   - correlated nested query의 결과가 비어(튜플이 없음) 있는 지 확인
      - EXITS(Q)는 query Q의 결과에 적어도 하나의 튜플이 있을 경우 TRUE를 반환하고, 그렇지 않을 경우 FALSE를 반환함
   - Q16B:
      ```
      SELECT   E.Fname, E.Lname
      FROM     EMPLOYEE AS E
      WHERE    EXISTS (
                        SELECT   *
                        FROM     DEPENDENT
                        WHERE    E.Ssn=Essn AND E.Sex=Sex AND E.Fname=Dependent_name   );
      ```
      
      ![08-18](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-18.jpg?raw=true)   
      
   - QUERY 6
      - 부양 가족이 없는 직원 이름 검색
   - Q6:
      ```
      SELECT   Fname, Lname
      FROM     EMPLOYEE
      WHERE    NOT EXITST ( SELECT  *
                            FROM    DEPENDENT
                            WHERE   Ssn=Essn );
      ```
      ![08-19](https://github.com/Jeongsiwook/DataBase/blob/master/img/08-19.jpg?raw=true)   
      
   - UNIQUE(Q) functions
      - query Q의 결과에 중복 튜플이 없는 경우 TRUE;
      - 그렇지 않으면 FALSE를 반환
      ```
      SELECT   Fname, Lname
      FROM     EMPLOYEE
      WHERE    UNIQUE ( SELECT   Sex
                        FROM     DEPENDENT
                        WHERE    Essn=EMPLOYEE.Ssn );
      ```
      
      ![08-20]()
      
   - QUERY 7
      - 하나 이상의 부양가족이 있는 관리자 이름을 나열하라
   - Q7:
      ![08-21]()   
      
      ![08-22]()   
      
      ```
      DELETE FROM EMPLOYEE
      WHERE  Dno=5;
      
      DELETE FROM EMPLOYEE
      WHERE  Dno IN (   SELECT   Dnumber
                        FROM     DEPARTMENT
                        WHERE    Dname='Research'  );
      
      UPDATE EMPLOYEE
      SET    Salary = Salary * 1.1
      WHERE  Dno IN (   SELECT   Dnumber
                        FROM     DEPARTMENT
                        WHERE    Dname='Research'  );
      ```
---

### Explicit Sets and Renaming Attributes
   - QUERY 17
      -
   - Q17:
      ```
      SELECT DISTINCT Essn
      FROM   WORKS_ON
      WHERE  Pno IN (1,2,3);
      ```
---

### Renaming Attributes
   - Q8A:
      ```
      SELECT   E.Lname AS Emp_Name, S.Lname AS Spvsr_Name
      FROM     EMPLOYEE AS E, EMPLOYEE AS S
      WHERE    E.Super_ssn=S.Ssn;
      ```
---

### Joined Table
   - query의 FROM-clause에서 조인 연산으로 인한 테이블 지정
   - Q1A:
      ```
      SELECT   Fname, Lname, Address
      FROM     (EMPLOYEE JOIN DEPARTMENT ON Dno=Dnumber)
      WHERE    Dname='Research';
      ```
      ![08-23]()   
      
      ![08-24]()  
      
      ![08-25]()   
      
   - Types of join: NATURAL JOIN, OUTER JOIN
   - R과 S의 두 관계에서 NATURAL JOIN을 할 때,
      - 조인 조건이 지정되지 않음
      - R과 S에서 이름이 같은 각 속성 쌍에 대한 암시적 EQUIJOIN 조건이 생성 됨
      - 이러한 각 속성 쌍은 결과 관계에 한 번만 포함됨 
      
      
      
      
   
      
         
         
